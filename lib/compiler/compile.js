/*** Generated by streamline 0.4.0b (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename),__func=__rt.__func,__cb=__rt.__cb,__tryCatch=__rt.__tryCatch; var fs = require("fs");








var fspath = require("path");

function _exists(callback, fname) {
  fspath.exists(fname, function(result) {
    callback(null, result); });};



function mtime(_, fname) { var __frame = { name: "mtime", line: 18 }; return __func(_, this, arguments, mtime, 0, __frame, function __$mtime() { return (function __$mtime(_) {
      return _exists(__cb(_, __frame, 1, 8, function ___(__0, __1) { var __2 = __1; return (function __$mtime(__then) { if (__2) { return fs.stat(fname, __cb(_, __frame, 1, 28, function ___(__0, __4) { var __3 = __4.mtime; return _(null, __3); }, true)); } else { __then(); } ; })(function __$mtime() { return _(null, 0); }); }, true), fname); })(__cb(_, __frame, -17, 6, _, true)); });};


function _getTransform(options) {

  var req = require;
  if (options.generators) {
    return req("../generators/transform"); }
   else if (options.fibers) {
    return req("../fibers/transform"); }
   else {
    return require("../callbacks/transform"); } ;};



function _banner(version) {

  return (("/*** Generated by streamline " + version) + " - DO NOT EDIT ***/");};


function _extend(obj, other) {
  for (var i in other) {
    obj[i] = other[i]; };

  return obj;};


function _transform(transform, source, options) {
  var sourceOptions = /streamline\.options\s*=\s*(\{.*\})/.exec(source);
  if (sourceOptions) {
    _extend(options, JSON.parse(sourceOptions[1])); };

  options.source = source;
  options.callback = (options.callback || "_");
  options.lines = (options.lines || "preserve");
  return transform.transform(source, options);};


function parseShebang(content) {
  if (((content[0] === "#") && (content[1] === "!"))) {
    var n = content.indexOf("\n");
    var le = "\n";
    if ((n != -1)) {
      var shebang = content.substr(0, n);
      if ((shebang[(shebang.length - 1)] == "\r")) {
        le = "\r\n";
        shebang = shebang.substr(0, (shebang.length - 1)); } ;

      content = content.substr((n + 1));
      return [shebang,content,le,]; } ; };


  return ["",content,"",];};


exports.compileFile = function exports_compileFile__1(_, js_, options) { var ext, language, basename, dirname, js, mtimejs_, mtimejs, transform, banner, content, shebangparse, shebang, le, coffee, transformed; var __frame = { name: "exports_compileFile__1", line: 74 }; return __func(_, this, arguments, exports_compileFile__1, 0, __frame, function __$exports_compileFile__1() {
    options = _extend({ }, (options || { }));
    ext = fspath.extname(js_);
    language = ext.substring(2);
    basename = fspath.basename(js_, ext);
    dirname = fspath.dirname(js_);
    js = (((dirname + "/") + basename) + ".js");
    return mtime(__cb(_, __frame, 7, 16, function ___(__0, __2) { mtimejs_ = __2;
      return mtime(__cb(_, __frame, 8, 15, function ___(__0, __3) { mtimejs = __3;
        transform = _getTransform(options);

        banner = _banner(transform.version);
        options.sourceName = js_;
        return fs.readFile(js_, "utf8", __cb(_, __frame, 13, 15, function ___(__0, __4) { content = __4;
          shebangparse = parseShebang(content);
          shebang = shebangparse[0];
          le = shebangparse[2];
          content = shebangparse[1];

          if ((language === "coffee")) {
            coffee = require("../util/require")("coffee-script");
            content = coffee.compile(content, {
              filename: js_ }); } ;



          banner = ((shebang + le) + banner); return (function __$exports_compileFile__1(_) {
            var __1 = mtimejs; if (!__1) { return _(null, __1); } ; return fs.readFile(js, "utf8", __cb(_, __frame, 27, 30, _, true)); })(__cb(_, __frame, -73, 6, function ___(__0, __5) { transformed = __5;
            if ((((transformed && (mtimejs_ < mtimejs)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) {
              return _(null, transformed); } ;

            if (options.verbose) {
              console.log(((("streamline: transforming: " + js_) + " to ") + js)); } ;

            transformed = ((shebang + banner) + _transform(transform, content, options)); return (function __$exports_compileFile__1(__then) {
              if (((options.action === "compile") || !dontSave)) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_compileFile__1() {


                      return fs.writeFile(js, transformed, "utf8", __cb(_, __frame, 38, 3, __then, true)); }); })(function ___(ex, __result) { __tryCatch(_, function __$exports_compileFile__1() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(_); }, true)); }, true)); }, true), js); }, true), js_); });};




var streamlineRE = /require\s*\(\s*['"]streamline\/module['"]\s*\)\s*\(\s*module\s*,?\s*([^)]*)?\s*\)/;












exports.loadFile = function exports_loadFile__2(_, path, options) { var ext, basename, dirname, mtimejs, mtimejs_, dontSave, jsbase, js, js_, fiberjs, transform, banner, content, shebangparse, shebang, le, transformed, matches; var __frame = { name: "exports_loadFile__2", line: 130 }; return __func(_, this, arguments, exports_loadFile__2, 0, __frame, function __$exports_loadFile__2() {
    options = _extend({ }, (options || { }));

    ext = fspath.extname(path); return (function __$exports_loadFile__2(__then) {
      if (((ext !== ".js") && (ext !== "._js"))) {

        return _exists(__cb(_, __frame, 6, 6, function ___(__0, __3) { return (function __$exports_loadFile__2(__then) { if (__3) { path = (path + (ext = "._js")); __then(); } else {
              return _exists(__cb(_, __frame, 7, 11, function ___(__0, __4) { return (function __$exports_loadFile__2(__then) { if (__4) { path = (path + (ext = ".js")); __then(); } else { return _(null); } ; })(__then); }, true), (path + ".js")); } ; })(__then); }, true), (path + "._js")); } else { __then(); } ; })(function __$exports_loadFile__2() {


      basename = fspath.basename(path, ext);
      dirname = fspath.dirname(path);


      dontSave = (basename[(basename.length - 1)] == "_");
      jsbase = (dontSave ? basename.substr(0, (basename.length - 1)) : basename);
      js = (((dirname + "/") + jsbase) + ext);
      js_ = ((((dirname + "/") + jsbase) + "_") + ext);
      fiberjs = ((((dirname + "/") + jsbase) + "--fibers") + ext); return (function __$exports_loadFile__2(_) {
        var __1 = options.fibers; if (!__1) { return _(null, __1); } ; return mtime(__cb(_, __frame, 19, 34, function ___(__0, __3) { var __2 = (mtimejs = __3); return _(null, __2); }, true), fiberjs); })(__cb(_, __frame, -129, 6, function ___(__0, __5) { return (function __$exports_loadFile__2(__then) { if (__5) {
            js = fiberjs; __then(); } else {

            return mtime(__cb(_, __frame, 22, 12, function ___(__0, __6) { mtimejs = __6; __then(); }, true), js); } ; })(function __$exports_loadFile__2() {

          return mtime(__cb(_, __frame, 24, 12, function ___(__0, __7) { mtimejs_ = __7;
            options.lines = (options.lines || "preserve");

            transform = _getTransform(options);
            banner = _banner(transform.version); return (function __$exports_loadFile__2(__then) {
              if (mtimejs_) {
                options.sourceName = js_;
                return fs.readFile(js_, "utf8", __cb(_, __frame, 31, 16, function ___(__0, __8) { content = __8;
                  shebangparse = parseShebang(content);
                  shebang = shebangparse[0];
                  le = shebangparse[2];
                  content = shebangparse[1];

                  banner = ((shebang + le) + banner); return (function __$exports_loadFile__2(_) {
                    var __2 = mtimejs; if (!__2) { return _(null, __2); } ; return fs.readFile(js, "utf8", __cb(_, __frame, 38, 31, _, true)); })(__cb(_, __frame, -129, 6, function ___(__0, __9) { transformed = __9;
                    if ((((transformed && (mtimejs_ < mtimejs)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) {
                      return _(null, transformed); } ;

                    if (options.verbose) {
                      console.log(((("streamline: transforming: " + js_) + " to ") + js)); } ;

                    transformed = ((shebang + banner) + _transform(transform, content, options)); return (function __$exports_loadFile__2(__then) {
                      if (((options.action === "compile") || !dontSave)) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_loadFile__2() {


                              return fs.writeFile(js, transformed, "utf8", __cb(_, __frame, 49, 4, __then, true)); }); })(function ___(ex, __result) { __tryCatch(_, function __$exports_loadFile__2() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(function __$exports_loadFile__2() {


                      return _(null, transformed); }); }, true)); }, true)); } else {

                options.sourceName = js;
                return fs.readFile(js, "utf8", __cb(_, __frame, 55, 16, function ___(__0, __10) { content = __10; return (function __$exports_loadFile__2(__then) {

                    if ((ext === "._js")) {
                      return cachedTransform(__cb(_, __frame, 58, 10, _, true), content, path, transform, banner, options); } else { return (function __$exports_loadFile__2(__then) {
                        if (matches = streamlineRE.exec(content)) {
                          content = removeMarker(content, matches, options);
                          return cachedTransform(__cb(_, __frame, 61, 10, _, true), content, path, transform, banner, options); } else {

                          return _(null, content); } ; })(__then); } ; })(__then); }, true)); } ; })(_); }, true), js_); }); }, true)); }); });};




function mtimeSync(fname) {
  try {
    return fs.statSync(fname).mtime;
  } catch (ex) {
    return 0; };};



function removeMarker(content, matches, options) {
  try {
    (matches[1] && _extend(options, JSON.parse(matches[1])));
  } catch (ex) {
    throw new Error(("Invalid JSON syntax for streamline options: " + matches[1])); };

  return ((content.substring(0, matches.index) + "true") + content.substring((matches.index + matches[0].length)));};


exports.transformModule = function(content, path, options) {
  options = _extend({ }, (options || { }));

  var ext = fspath.extname(path);
  var basename = fspath.basename(path, ext);
  var dirname = fspath.dirname(path);

  var mtimejs, mtimejs_;
  var dontSave = (basename[(basename.length - 1)] == "_");
  var jsbase = (dontSave ? basename.substr(0, (basename.length - 1)) : basename);
  var js = (((dirname + "/") + jsbase) + ext);
  var js_ = ((((dirname + "/") + jsbase) + "_") + ext);
  var fiberjs = ((((dirname + "/") + jsbase) + "--fibers") + ext);
  if ((options.fibers && (mtimejs = mtimeSync(fiberjs)))) {
    js = fiberjs; }
   else {
    mtimejs = mtimeSync(js); };

  mtimejs_ = mtimeSync(js_);
  options.lines = (options.lines || "preserve");

  var transform = _getTransform(options);
  var banner = _banner(transform.version);

  if (mtimejs_) {
    options.sourceName = js_;
    if (!dontSave) {
      content = fs.readFileSync(js_, "utf8"); };
    var shebangparse = parseShebang(content);
    var shebang = shebangparse[0];
    var le = shebangparse[2];
    content = shebangparse[1];

    banner = ((shebang + le) + banner);
    var transformed = (mtimejs && fs.readFileSync(js, "utf8"));
    if ((((transformed && (mtimejs_ < mtimejs)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) { return transformed };
    if (options.verbose) { console.log(("streamline: transforming: " + js_)); };
    var transformed = (banner + _transform(transform, content, options));
    if (!dontSave) {

      try {
        fs.writeFileSync(js, transformed, "utf8");
      } catch (ex) {  }; } ;

    return transformed; }
   else {
    options.sourceName = path;
    var matches;
    if (((ext !== ".js") && (ext !== ".coffee"))) {

      var shebangparse = parseShebang(content);
      var shebang = shebangparse[0];
      content = (shebangparse[2] + shebangparse[1]);
      return transform.transform(content, options); }
     else if (matches = streamlineRE.exec(content)) {
      content = removeMarker(content, matches, options);
      return cachedTransformSync(content, path, transform, banner, options); }
     else {
      return content; }  ; };};




if (((process.env.HOME === undefined) && (process.env.HOMEDRIVE === undefined))) { throw new Error("HOME not found, unable to store Streamline callback cache")};
var root = (((process.env.HOME || ((process.env.HOMEDRIVE + process.env.HOMEPATH)).replace(/\\/g, "/"))) + "/.streamline");

var dirMode = parseInt("777", 8);

function mkdirs(_, path) { var p, i, segs, seg; var __frame = { name: "mkdirs", line: 283 }; return __func(_, this, arguments, mkdirs, 0, __frame, function __$mkdirs() {
    p = "";
    i = 0;
    segs = path.split("/").slice(0, -1); return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$mkdirs() { __more = false;
        var __3 = (i < segs.length); if (__3) {
          seg = segs[i];
          p += (((i++ ? "/" : "")) + seg); return (function __$mkdirs(_) {
            var __1 = (i > 1); if (!__1) { return _(null, __1); } ; return _exists(__cb(_, __frame, 7, 16, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true), p); })(__cb(_, __frame, -282, 6, function ___(__0, __2) { return (function __$mkdirs(__then) { if (__2) { return fs.mkdir(p, dirMode, __cb(_, __frame, 7, 31, __then, true)); } else { __then(); } ; })(function __$mkdirs() { while (__more) { __loop(); }; __more = true; }); }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(_); });};



function subdir(options) {
  return (options.generators ? "generators" : (options.fibers ? "fibers" : "callbacks"));};


function cachedTransform(_, content, path, transform, banner, options) { var i, dir, f, transformed; var __frame = { name: "cachedTransform", line: 298 }; return __func(_, this, arguments, cachedTransform, 0, __frame, function __$cachedTransform() {
    path = path.replace(/\\/g, "/");
    i = path.indexOf("node_modules/");
    if ((i < 0)) { i = path.lastIndexOf("/"); } else {
      i += "node_modules".length; } ;

    dir = ((root + "/") + subdir(options));
    dir += ("/" + path.substring(0, i).replace(/[\/\:]/g, "__"));
    f = (dir + path.substring(i));
    return mkdirs(__cb(_, __frame, 9, 1, function __$cachedTransform() {

      return mtime(__cb(_, __frame, 11, 5, function ___(__0, __2) { return mtime(__cb(_, __frame, 11, 19, function ___(__0, __3) { var __1 = (__2 > __3); return (function __$cachedTransform(__then) { if (__1) {
              return fs.readFile(f, "utf8", __cb(_, __frame, 12, 16, function ___(__0, __4) { transformed = __4;
                if ((transformed.substring(0, banner.length) === banner)) { return _(null, transformed); } ; __then(); }, true)); } else { __then(); } ; })(function __$cachedTransform() {


            if (options.verbose) { console.log(("streamline: transforming: " + path)); } ;
            options.lines = "preserve";
            transformed = (banner + _transform(transform, content, options)); return (function __$cachedTransform(__then) {
              if ((path.indexOf("/tmp--") < 0)) { return fs.writeFile(f, transformed, "utf8", __cb(_, __frame, 19, 33, __then, true)); } else { __then(); } ; })(function __$cachedTransform() {
              return _(null, transformed); }); }); }, true), path); }, true), f); }, true), f); });};


function mkdirsSync(path) {
  var p = "", i = 0;

  path.split("/").slice(0, -1).forEach(function(seg) {
    p += (((i++ ? "/" : "")) + seg);
    if (((i > 1) && !fspath.existsSync(p))) { fs.mkdirSync(p, dirMode); }; });};



function cachedTransformSync(content, path, transform, banner, options) {
  path = path.replace(/\\/g, "/");
  var i = path.indexOf("node_modules/");
  if ((i < 0)) { i = path.lastIndexOf("/"); } else {
    i += "node_modules".length; };

  var dir = ((root + "/") + subdir(options));
  dir += ("/" + path.substring(0, i).replace(/[\/:]/g, "__"));
  var f = (dir + path.substring(i));
  mkdirsSync(f);
  var transformed;
  if ((mtimeSync(f) > mtimeSync(path))) {
    transformed = fs.readFileSync(f, "utf8");
    if ((transformed.substring(0, banner.length) === banner)) { return transformed }; };


  if (options.verbose) { console.log(("streamline: transforming: " + path)); };
  var opts = Object.keys(options).reduce(function(r, k) {
    r[k] = options[k];
    return r;
  }, { });
  opts.lines = "preserve";
  transformed = (banner + _transform(transform, content, opts));
  if ((path.indexOf("/tmp--") < 0)) { fs.writeFileSync(f, transformed, "utf8"); };
  return transformed;};


exports.cachedTransformSync = function(content, path, transform, options) {
  var banner = _banner(transform.version);
  return cachedTransformSync(content, path, {
    transform: transform
  }, banner, options);};







exports.compile = function exports_compile__3(_, paths, options) { var failed, transform, cwd;
  function _compile(_, path, options) { var stat, ext, jsPath, source, coffee, compiled, matches; var __frame = { name: "_compile", line: 370 }; return __func(_, this, arguments, _compile, 0, __frame, function __$_compile() {
      return fs.stat(path, __cb(_, __frame, 1, 13, function ___(__0, __3) { stat = __3; return (function __$_compile(__then) {
          if (stat.isDirectory()) {
            return fs.readdir(path, __cb(_, __frame, 3, 3, function ___(__0, __4) { return __4.forEach_(__cb(_, __frame, 3, 3, __then, true), function __1(_, f) { var __frame = { name: "__1", line: 373 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() {
                  return _compile(__cb(_, __frame, 1, 4, _, true), ((path + "/") + f), options); }); }); }, true)); } else { return (function __$_compile(__then) {

              if (stat.isFile()) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$_compile() {

                      return exports.loadFile(__cb(_, __frame, 8, 4, function __$_compile() {
                        ext = fspath.extname(path); return (function __$_compile(__then) {
                          if (((ext === "._js") || (ext === "._coffee"))) {
                            return exports.compileFile(__cb(_, __frame, 11, 5, __then, true), path, options); } else { return (function __$_compile(__then) {
                              if (((ext === ".coffee") && (path[((path.length - ext.length) - 1)] !== "_"))) {
                                jsPath = (path.substring(0, (path.length - ext.length)) + ".js"); return (function __$_compile(_) {
                                  var __2 = options.force; if (__2) { return _(null, __2); } ; return mtime(__cb(_, __frame, 14, 26, function ___(__0, __4) { return mtime(__cb(_, __frame, 14, 43, function ___(__0, __5) { var __3 = (__4 > __5); return _(null, __3); }, true), jsPath); }, true), path); })(__cb(_, __frame, -369, 6, function ___(__0, __5) { return (function __$_compile(__then) { if (__5) {
                                      return fs.readFile(path, "utf8", __cb(_, __frame, 15, 19, function ___(__0, __6) { source = __6;
                                        coffee = require("../util/require")("coffee-script");
                                        compiled = coffee.compile(source, {
                                          filename: path });

                                        matches = streamlineRE.exec(compiled);
                                        if (matches) {
                                          if (options.verbose) { console.log(((("streamline: transforming: " + path) + " to ") + jsPath)); } ;
                                          compiled = removeMarker(compiled, matches, options);
                                          compiled = _transform(_getTransform(options), compiled, options); }
                                         else {
                                          if (options.verbose) { console.log(((("streamline: coffee compiling: " + path) + " to ") + jsPath)); } ; } ;

                                        return fs.writeFile(jsPath, compiled, "utf8", __cb(_, __frame, 28, 6, __then, true)); }, true)); } else { __then(); } ; })(__then); }, true)); } else {


                                return exports.loadFile(__cb(_, __frame, 31, 5, __then, true), path, options); } ; })(__then); } ; })(__then); }, true), path, options); }); })(function ___(ex, __result) { __tryCatch(_, function __$_compile() { if (ex) {


                        console.error(ex.stack);
                        failed++; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(__then); } ; })(_); }, true)); }); }; var __frame = { name: "exports_compile__3", line: 369 }; return __func(_, this, arguments, exports_compile__3, 0, __frame, function __$exports_compile__3() {





    failed = 0;
    options = (options || { });
    transform = _getTransform(options);
    if (options.verbose) { console.log(("transform version: " + transform.version)); } ;
    if ((!paths || (paths.length == 0))) { return _(new Error("cannot compile: no files specified")); } ;
    cwd = process.cwd();
    return paths.forEach_(__cb(_, __frame, 48, 1, function __$exports_compile__3() {


      if (failed) { return _(new Error((("errors found in " + failed) + " files"))); } ; _(); }, true), function __1(_, path) { var __frame = { name: "__1", line: 417 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return _compile(__cb(_, __frame, 1, 2, _, true), fspath.resolve(cwd, path), options); }); }); });};