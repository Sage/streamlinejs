/*** Generated by streamline 0.2.2 - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename),__func=__rt.__func,__cb=__rt.__cb,__tryCatch=__rt.__tryCatch,__propagate=__rt.__propagate,__trap=__rt.__trap,__future=__rt.__future,__setEF=__rt.__setEF,__g=__rt.__g; var fs = require("fs");









var fspath = require("path");

function _exists(callback, fname) {
 fspath.exists(fname, function(result) {
 callback(null, result); });};



function mtime(_, fname) { var __frame = { name: "mtime", line: 19 }; return __func(_, this, arguments, mtime, 0, __frame, function __$mtime() { return (function __$mtime(_) {
 return _exists(__cb(_, __frame, 1, 8, function ___(__0, __1) { var __2 = __1; return (function __$mtime(__then) { if (__2) { return fs.stat(fname, __cb(_, __frame, 1, 28, function ___(__0, __4) { var __3 = __4.mtime; return _(null, __3); })); } else { __then(); } ; })(function __$mtime() { return _(null, 0); }); }), fname); })(__cb(_, __frame, -18, 21, _)); });};


function _getTransform(options) {
 if (options.fibers) {

 var req = require;
 return req("../fibers/transform"); }
 else {
 return require("../callbacks/transform"); };};



function _banner(version) {

 return (("/*** Generated by streamline " + version) + " - DO NOT EDIT ***/");};


function _extend(obj, other) {
 for (var i in other) {
 obj[i] = other[i]; };

 return obj;};


function _transform(transform, source, options) {
 var sourceOptions = /streamline\.options\s*=\s*(\{.*\})/.exec(source);
 if (sourceOptions) {
 _extend(options, JSON.parse(sourceOptions[1])); };

 source = source.replace(/\r\n/g, "\n");
 options.source = source;
 options.callback = (options.callback || "_");
 options.lines = (options.lines || "mark");
 return transform.transform(source, options);};


function parseShebang(content) {
 if (((content[0] === "#") && (content[1] === "!"))) {
 var n = content.indexOf("\n");
 var le = "\n";
 if ((n != -1)) {
 var shebang = content.substr(0, n);
 if ((shebang[(shebang.length - 1)] == "\r")) {
 le = "\r\n";
 shebang = shebang.substr(0, (shebang.length - 1)); } ;

 content = content.substr((n + 1));
 return [shebang,content,le,]; } ; };


 return ["",content,"",];};


var streamlineRE = /require\s*\(\s*['"]streamline\/module['"]\s*\)\s*\(\s*module\s*,?\s*([^)]*)?\s*\)/;












exports.loadFile = function exports_loadFile__1(_, path, options) { var ext, basename, dirname, mtimejs, mtimejs_, dontSave, jsbase, js, js_, fiberjs, transform, banner, content, shebangparse, shebang, le, transformed, matches; var __frame = { name: "exports_loadFile__1", line: 87 }; return __func(_, this, arguments, exports_loadFile__1, 0, __frame, function __$exports_loadFile__1() {
 options = _extend({ }, (options || { }));

 ext = fspath.extname(path);
 basename = fspath.basename(path, ext);
 dirname = fspath.dirname(path);
 if ((ext !== ".js")) { return _(null); } ;


 dontSave = (basename[(basename.length - 1)] == "_");
 jsbase = (dontSave ? basename.substr(0, (basename.length - 1)) : basename);
 js = (((dirname + "/") + jsbase) + ext);
 js_ = ((((dirname + "/") + jsbase) + "_") + ext);
 fiberjs = ((((dirname + "/") + jsbase) + "--fibers") + ext); return (function __$exports_loadFile__1(_) {
 var __1 = options.fibers; if (!__1) { return _(null, __1); } ; return mtime(__cb(_, __frame, 14, 34, function ___(__0, __3) { var __2 = (mtimejs = __3); return _(null, __2); }), fiberjs); })(__cb(_, __frame, -86, 21, function ___(__0, __3) { return (function __$exports_loadFile__1(__then) { if (__3) {
 js = fiberjs; __then(); } else {

 return mtime(__cb(_, __frame, 17, 12, function ___(__0, __4) { mtimejs = __4; __then(); }), js); } ; })(function __$exports_loadFile__1() {

 return mtime(__cb(_, __frame, 19, 12, function ___(__0, __5) { mtimejs_ = __5;
 options.lines = (options.lines || ((dontSave ? "preserve" : "mark")));

 transform = _getTransform(options);
 banner = _banner(transform.version); return (function __$exports_loadFile__1(__then) {
 if (mtimejs_) {
 options.sourceName = js_;
 return fs.readFile(js_, "utf8", __cb(_, __frame, 26, 16, function ___(__0, __6) { content = __6;
 shebangparse = parseShebang(content);
 shebang = shebangparse[0];
 le = shebangparse[2];
 content = shebangparse[1];

 banner = ((shebang + le) + banner); return (function __$exports_loadFile__1(_) {
 var __2 = mtimejs; if (!__2) { return _(null, __2); } ; return fs.readFile(js, "utf8", __cb(_, __frame, 33, 31, _)); })(__cb(_, __frame, -86, 21, function ___(__0, __7) { transformed = __7;
 if ((((transformed && (mtimejs_ < mtimejs)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) {
 return _(null, transformed); } ;

 if (options.verbose) {
 console.log(((("streamline: transforming: " + js_) + " to ") + js)); } ;

 transformed = ((shebang + banner) + _transform(transform, content, options));
 if (((options.action === "compile") || !dontSave)) {

 try {
 fs.writeFile(js, transformed, "utf8");
 } catch (ex) {  }; } ;

 return _(null, transformed); })); })); } else {

 options.sourceName = js;
 return fs.readFile(js, "utf8", __cb(_, __frame, 50, 16, function ___(__0, __8) { content = __8; return (function __$exports_loadFile__1(__then) {

 if (matches = streamlineRE.exec(content)) {
 try {
 (matches[1] && _extend(options, JSON.parse(matches[1])));
 } catch (ex) {
 return _(new Error(("Invalid JSON syntax for streamline options: " + matches[1]))); };

 content = ((content.substring(0, matches.index) + "true") + content.substring((matches.index + matches[0].length)));
 return cachedTransform(__cb(_, __frame, 59, 10, _), content, path, transform, banner, options); } else {

 return _(null, content); } ; })(__then); })); } ; })(_); }), js_); }); })); });};




function mtimeSync(fname) {
 try {
 return fs.statSync(fname).mtime;
 } catch (ex) {
 return 0; };};






exports.transformModule = function(content, path, options) {
 options = _extend({ }, (options || { }));

 var ext = fspath.extname(path);
 var basename = fspath.basename(path, ext);
 var dirname = fspath.dirname(path);

 var mtimejs, mtimejs_;
 var dontSave = (basename[(basename.length - 1)] == "_");
 var jsbase = (dontSave ? basename.substr(0, (basename.length - 1)) : basename);
 var js = (((dirname + "/") + jsbase) + ext);
 var js_ = ((((dirname + "/") + jsbase) + "_") + ext);
 var fiberjs = ((((dirname + "/") + jsbase) + "--fibers") + ext);
 if ((options.fibers && (mtimejs = mtimeSync(fiberjs)))) {
 js = fiberjs; }
 else {
 mtimejs = mtimeSync(js); };

 mtimejs_ = mtimeSync(js_);
 options.lines = (options.lines || ((dontSave ? "preserve" : "mark")));

 var transform = _getTransform(options);
 var banner = _banner(transform.version);

 if (mtimejs_) {
 options.sourceName = js_;
 if (!dontSave) {
 content = fs.readFileSync(js_, "utf8"); };
 var shebangparse = parseShebang(content);
 var shebang = shebangparse[0];
 var le = shebangparse[2];
 content = shebangparse[1];

 banner = ((shebang + le) + banner);
 var transformed = (mtimejs && fs.readFileSync(js, "utf8"));
 if ((((transformed && (mtimejs_ < mtimejs)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) { return transformed };
 if (options.verbose) { console.log(("streamline: transforming: " + js_)); };
 var transformed = (banner + _transform(transform, content, options));
 if (!dontSave) {

 try {
 fs.writeFileSync(js, transformed, "utf8");
 } catch (ex) {  }; } ;

 return transformed; }
 else {
 options.sourceName = path;
 var matches;
 if (((ext !== ".js") && (ext !== ".coffee"))) {

 var shebangparse = parseShebang(content);
 var shebang = shebangparse[0];
 content = (shebangparse[2] + shebangparse[1]);
 return transform.transform(content, options); }
 else if (matches = streamlineRE.exec(content)) {
 try {
 (matches[1] && _extend(options, JSON.parse(matches[1])));
 } catch (ex) {
 throw new Error(("Invalid JSON syntax for streamline options: " + matches[1])); };

 content = ((content.substring(0, matches.index) + "true") + content.substring((matches.index + matches[0].length)));
 return cachedTransformSync(content, path, transform, banner, options); }
 else {
 return content; }  ; };};




var root = (((process.env.HOME || ((process.env.HOMEDRIVE + process.env.HOMEPATH)).replace(/\\/g, "/"))) + "/.streamline");

var dirMode = parseInt("777", 8);

function mkdirs(_, path) { var p, i, segs, seg; var __frame = { name: "mkdirs", line: 236 }; return __func(_, this, arguments, mkdirs, 0, __frame, function __$mkdirs() {
 p = "";
 i = 0;
 segs = path.split("/").slice(0, -1); return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$mkdirs() { __more = false;
 var __3 = (i < segs.length); if (__3) {
 seg = segs[i];
 p += (((i++ ? "/" : "")) + seg); return (function __$mkdirs(_) {
 var __1 = (i > 1); if (!__1) { return _(null, __1); } ; return _exists(__cb(_, __frame, 7, 16, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }), p); })(__cb(_, __frame, -235, 21, function ___(__0, __2) { return (function __$mkdirs(__then) { if (__2) { return fs.mkdir(p, dirMode, __cb(_, __frame, 7, 31, __then)); } else { __then(); } ; })(function __$mkdirs() { while (__more) { __loop(); }; __more = true; }); })); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(_); });};



function cachedTransform(_, content, path, transform, banner, options) { var i, dir, f, transformed; var __frame = { name: "cachedTransform", line: 247 }; return __func(_, this, arguments, cachedTransform, 0, __frame, function __$cachedTransform() {
 path = path.replace(/\\/g, "/");
 i = path.indexOf("node_modules/");
 if ((i < 0)) { i = path.lastIndexOf("/"); } else {
 i += "node_modules".length; } ;

 dir = ((root + "/") + ((options.fibers ? "fibers" : "callbacks")));
 dir += ("/" + path.substring(0, i).replace(/[\/\:]/g, "__"));
 f = (dir + path.substring(i));
 return mkdirs(__cb(_, __frame, 9, 1, function __$cachedTransform() {

 return mtime(__cb(_, __frame, 11, 5, function ___(__0, __2) { return mtime(__cb(_, __frame, 11, 19, function ___(__0, __3) { var __1 = (__2 > __3); return (function __$cachedTransform(__then) { if (__1) {
 return fs.readFile(f, "utf8", __cb(_, __frame, 12, 16, function ___(__0, __4) { transformed = __4;
 if ((transformed.substring(0, banner.length) === banner)) { return _(null, transformed); } ; __then(); })); } else { __then(); } ; })(function __$cachedTransform() {


 if (options.verbose) { console.log(("streamline: transforming: " + path)); } ;
 options.lines = "preserve";
 transformed = (banner + _transform(transform, content, options)); return (function __$cachedTransform(__then) {
 if ((path.indexOf("/tmp--") < 0)) { return fs.writeFile(f, transformed, "utf8", __cb(_, __frame, 19, 33, __then)); } else { __then(); } ; })(function __$cachedTransform() {
 return _(null, transformed); }); }); }), path); }), f); }), f); });};


function mkdirsSync(path) {
 var p = "", i = 0;

 path.split("/").slice(0, -1).forEach(function(seg) {
 p += (((i++ ? "/" : "")) + seg);
 if (((i > 1) && !fspath.existsSync(p))) { fs.mkdirSync(p, dirMode); }; });};



function cachedTransformSync(content, path, transform, banner, options) {
 path = path.replace(/\\/g, "/");
 var i = path.indexOf("node_modules/");
 if ((i < 0)) { i = path.lastIndexOf("/"); } else {
 i += "node_modules".length; };

 var dir = ((root + "/") + ((options.fibers ? "fibers" : "callbacks")));
 dir += ("/" + path.substring(0, i).replace(/[\/:]/g, "__"));
 var f = (dir + path.substring(i));
 mkdirsSync(f);
 var transformed;
 if ((mtimeSync(f) > mtimeSync(path))) {
 transformed = fs.readFileSync(f, "utf8");
 if ((transformed.substring(0, banner.length) === banner)) { return transformed }; };


 if (options.verbose) { console.log(("streamline: transforming: " + path)); };
 options.lines = "preserve";
 transformed = (banner + _transform(transform, content, options));
 if ((path.indexOf("/tmp--") < 0)) { fs.writeFileSync(f, transformed, "utf8"); };
 return transformed;};








exports.compile = function exports_compile__2(_, paths, options) { var flows, failed, transform, cwd;



 function _compile(_, path, options) { var stat; var __frame = { name: "_compile", line: 312 }; return __func(_, this, arguments, _compile, 0, __frame, function __$_compile() {
 return fs.stat(path, __cb(_, __frame, 1, 13, function ___(__0, __2) { stat = __2; return (function __$_compile(__then) {
 if (stat.isDirectory()) {
 return fs.readdir(path, __cb(_, __frame, 3, 17, function ___(__0, __3) { return flows.each(__cb(_, __frame, 3, 3, __then), __3, function __1(_, f) { var __frame = { name: "__1", line: 315 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() {
 return _compile(__cb(_, __frame, 1, 4, _), ((path + "/") + f), options); }); }); })); } else { return (function __$_compile(__then) {

 if (stat.isFile()) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$_compile() {

 return exports.loadFile(__cb(_, __frame, 8, 4, __then), path, options); }); })(function ___(ex, __result) { __tryCatch(_, function __$_compile() { if (ex) {

 console.error(ex.stack);
 failed++; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(__then); } ; })(_); })); }); }; var __frame = { name: "exports_compile__2", line: 308 }; return __func(_, this, arguments, exports_compile__2, 0, __frame, function __$exports_compile__2() { flows = require("../util/flows");





 failed = 0;
 options = (options || { });
 transform = _getTransform(options);
 if (options.verbose) { console.log(("transform version: " + transform.version)); } ;
 if ((!paths || (paths.length == 0))) { return _(new Error("cannot compile: no files specified")); } ;
 cwd = process.cwd();
 return flows.each(__cb(_, __frame, 27, 1, function __$exports_compile__2() {


 if (failed) { return _(new Error((("errors found in " + failed) + " files"))); } ; _(); }), paths, function __1(_, path) { var __frame = { name: "__1", line: 335 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return _compile(__cb(_, __frame, 1, 2, _), fspath.resolve(cwd, path), options); }); }); });};