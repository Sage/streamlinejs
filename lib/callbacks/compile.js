/*** Generated by streamline 0.10.12 (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('../callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var fs = require("fs");








var fspath = require("path");
var compileSync = require("../compiler/compileSync");

var _exists = __rt.streamlinify(function(cb, fname) {
  fs.exists(fname, function(result) {
    cb(null, result); });

}, 0);

function mtime(_, fname) { var __frame = { name: "mtime", line: 19 }; return __func(_, this, arguments, mtime, 0, __frame, function __$mtime() { return (function __$mtime(_) {
      return _exists(__cb(_, __frame, 1, 8, function ___(__0, __1) { var __2 = __1; return (function __$mtime(__then) { if (__2) { return fs.stat(fname, __cb(_, __frame, 1, 31, function ___(__0, __4) { var __3 = __4.mtime; return _(null, __3); }, true)); } else { __then(); } ; })(function __$mtime() { return _(null, 0); }); }, true), fname); })(__cb(_, __frame, -18, 6, _, true)); });};


var _0755 = parseInt("0755", 8);

function _getTransform(options) {

  var req = require;
  if (options.generators) {
    if (options.fast) { return req("../generators-fast/transform"); } else {
      return req("../generators/transform") }; }
   else if (options.fibers) {
    if (options.fast) { return req("../fibers-fast/transform"); } else {
      return req("../fibers/transform") }; }
   else {
    return require("../callbacks/transform"); }  ;};



function _banner(version, options) {

  var optStr = (options.oldStyleFutures ? " --old-style-futures" : "");
  if (options.promise) { optStr += (" --promise-" + options.promise); };
  if (options.standalone) { optStr += " --standalone"; };
  return ((("/*** Generated by streamline " + version) + optStr) + " - DO NOT EDIT ***/");};


function _extend(obj, other) {
  for (var i in other) {
    obj[i] = other[i]; };

  return obj;};


function _transform(transform, source, options) {
  options.source = source;
  options.callback = (options.callback || "_");
  options.lines = (options.lines || "preserve");
  return transform.transform(source, options);};


function parseShebang(content) {
  if (((content[0] === "#") && (content[1] === "!"))) {
    var n = content.indexOf("\n");
    var le = "\n";
    if ((n != -1)) {
      var shebang = content.substr(0, n);
      if ((shebang[(shebang.length - 1)] == "\r")) {
        le = "\r\n";
        shebang = shebang.substr(0, (shebang.length - 1)); } ;

      content = content.substr((n + 1));
      return [shebang,content,le,]; } ; } ;


  return ["",content,"",];};


function mkdirp(_, path) { var __frame = { name: "mkdirp", line: 78 }; return __func(_, this, arguments, mkdirp, 0, __frame, function __$mkdirp() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$mkdirp() {

          return fs.mkdir(path, _0755, __cb(_, __frame, 2, 5, __then, true)); }); })(function ___(err, __result) { __catch(function __$mkdirp() { if (err) { return (function __$mkdirp(__then) {

              if ((err.code == "EEXIST")) {
                return fs.stat(path, __cb(_, __frame, 5, 10, function ___(__0, __2) { var __1 = __2.isDirectory(); return (function __$mkdirp(__then) { if (__1) { return _(null); } else { __then(); } ; })(function __$mkdirp() {


                    return _(err); }); }, true)); } else { __then(); } ; })(function __$mkdirp() { return (function __$mkdirp(__then) {

                if ((err.code == "ENOENT")) {
                  return mkdirp(__cb(_, __frame, 11, 3, function __$mkdirp() {
                    return fs.mkdir(path, _0755, __cb(_, __frame, 12, 6, function __$mkdirp() { return _(null); }, true)); }, true), fspath.join(path, "..")); } else { __then(); } ; })(function __$mkdirp() {


                return _(err); }); }); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$mkdirp() { _(); }); }); });};



function outputFile(_, inFile, options) { var dirname, outDir, stripped; var __frame = { name: "outputFile", line: 97 }; return __func(_, this, arguments, outputFile, 0, __frame, function __$outputFile() {
    dirname = fspath.dirname(inFile);

    if (options.outputDir) {
      if (options.baseDir) {
        outDir = fspath.join(options.outputDir, fspath.relative(options.baseDir, dirname)); }
       else {
        outDir = options.outputDir; } ; }

     else {
      outDir = dirname; } ;

    return mkdirp(__cb(_, __frame, 12, 1, function __$outputFile() {
      stripped = fspath.basename(inFile, fspath.extname(inFile));
      return _(null, fspath.join(outDir, (stripped + ".js"))); }, true), outDir); });};



exports.compileFile = function exports_compileFile__1(_, path, options) { var ext, language, basename, relpath, dstName, dirname, mtimeSrc, mtimeDst, transform, banner, content, shebangparse, shebang, le, coffee, transformed, sourceMap, mapFile, mapPath; var __frame = { name: "exports_compileFile__1", line: 115 }; return __func(_, this, arguments, exports_compileFile__1, 0, __frame, function __$exports_compileFile__1() {
    options = _extend({ }, (options || { }));
    ext = fspath.extname(path);
    language = ext.substring(2);
    basename = fspath.basename(path, ext);
    relpath = fspath.relative(".", path);
    return outputFile(__cb(_, __frame, 6, 15, function ___(__0, __2) { dstName = __2;
      dirname = fspath.dirname(dstName);

      return mtime(__cb(_, __frame, 9, 16, function ___(__0, __3) { mtimeSrc = __3;
        return mtime(__cb(_, __frame, 10, 16, function ___(__0, __4) { mtimeDst = __4;
          transform = _getTransform(options);

          banner = _banner(transform.version, options);
          options.sourceName = relpath;
          return fs.readFile(path, "utf8", __cb(_, __frame, 15, 18, function ___(__0, __5) { content = __5;
            shebangparse = parseShebang(content);
            shebang = shebangparse[0];
            le = shebangparse[2];
            content = shebangparse[1];

            if ((language === "coffee")) {
              coffee = require("../util/require")("coffee-script");
              if (options.sourceMap) {
                content = coffee.compile(content, {
                  filename: relpath,
                  sourceFiles: [relpath,],
                  sourceMap: 1 });

                options.prevMap = new (require("source-map").SourceMapConsumer)(content.v3SourceMap);
                content = content.js; }
               else {
                content = coffee.compile(content, {
                  filename: path }); } ; } ;




            if (options.sourceMap) {
              options.lines = "sourcemap"; } ;


            banner = ((shebang + le) + banner); return (function __$exports_compileFile__1(_) {
              var __1 = mtimeDst; if (!__1) { return _(null, __1); } ; return fs.readFile(dstName, "utf8", __cb(_, __frame, 43, 34, _, true)); })(__cb(_, __frame, -114, 6, function ___(__0, __6) { transformed = __6;
              if ((((transformed && (mtimeSrc < mtimeDst)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) {
                return _(null, transformed); } ;

              if (options.verbose) {
                console.log(("streamline: creating: " + dstName)); } ;

              transformed = _transform(transform, content, options);

              mapFile = (options.sourceMapFile || fspath.join(dirname, (basename + ".map")));
              if ((typeof transformed == "string")) {
                transformed = (banner + transformed);
                if (options.prevMap) {
                  transformed += (("\n//# sourceMappingURL=" + ((options.sourceMapFile || ((basename + ".map"))))) + "\n");
                  sourceMap = require("source-map").SourceMapGenerator.fromSourceMap(options.prevMap);
                  options.prevMap = null; } ; }

               else {
                transformed.prepend(banner);
                if (options.sourceMap) {
                  transformed.add((("\n//# sourceMappingURL=" + ((options.sourceMapFile || ((basename + ".map"))))) + "\n"));
                  mapPath = fspath.dirname(mapFile);
                  sourceMap = transformed.toStringWithSourceMap({
                    file: fspath.relative(mapPath, dstName),
                    sourceRoot: fspath.relative(mapPath, ".") });

                  transformed = sourceMap.code;
                  sourceMap = sourceMap.map; } ; } ; return (function __$exports_compileFile__1(__then) {


                if (options.noWrite) {
                  return _(null, {
                    transformed: transformed,
                    sourceMap: sourceMap }); } else { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_compileFile__1() {





                        return fs.writeFile(dstName, transformed, "utf8", __cb(_, __frame, 82, 6, __then, true)); }); })(function ___(ex, __result) { __catch(function __$exports_compileFile__1() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$exports_compileFile__1() { return (function __$exports_compileFile__1(__then) {

                        if (options.sourceMap) {
                          if (options.prevMap) {
                            sourceMap.applySourceMap(options.prevMap, options.sourceName); } ; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_compileFile__1() {


                                if (options.verbose) { console.log(("streamline: creating: " + mapFile)); } ;
                                return fs.writeFile(mapFile, sourceMap.toString(), "utf8", __cb(_, __frame, 90, 7, __then, true)); }); })(function ___(ex, __result) { __catch(function __$exports_compileFile__1() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(__then); }); }); } ; })(_); }, true)); }, true)); }, true), dstName); }, true), path); }, true), path, options); });};










exports.loadFile = function exports_loadFile__2(_, path, options) { var ext, basename, dirname, js, transform, banner, content, shebangparse, shebang, le, matches; var __frame = { name: "exports_loadFile__2", line: 216 }; return __func(_, this, arguments, exports_loadFile__2, 0, __frame, function __$exports_loadFile__2() {
    options = _extend({ }, (options || { }));

    ext = fspath.extname(path); return (function __$exports_loadFile__2(__then) {
      if (((ext !== ".js") && (ext !== "._js"))) {

        return _exists(__cb(_, __frame, 6, 6, function ___(__0, __1) { return (function __$exports_loadFile__2(__then) { if (__1) { path = (path + (ext = "._js")); __then(); } else {
              return _exists(__cb(_, __frame, 7, 11, function ___(__0, __2) { return (function __$exports_loadFile__2(__then) { if (__2) { path = (path + (ext = ".js")); __then(); } else { return _(null); } ; })(__then); }, true), (path + ".js")); } ; })(__then); }, true), (path + "._js")); } else { __then(); } ; })(function __$exports_loadFile__2() {


      basename = fspath.basename(path, ext);
      dirname = fspath.dirname(path);

      js = (((dirname + "/") + basename) + ext);
      options.lines = (options.lines || "preserve");

      transform = _getTransform(options);
      banner = _banner(transform.version, options);
      options.sourceName = js;
      return fs.readFile(js, "utf8", __cb(_, __frame, 19, 18, function ___(__0, __3) { content = __3;
        shebangparse = parseShebang(content);
        shebang = shebangparse[0];
        le = shebangparse[2];
        content = shebangparse[1];

        banner = ((shebang + le) + banner); return (function __$exports_loadFile__2(__then) {

          if ((ext === "._js")) {
            return cachedTransform(__cb(_, __frame, 28, 9, _, true), content, path, transform, banner, options); } else {

            return _(null, content); } ; })(_); }, true)); }); });};



exports.transformModule = compileSync.transformModule;

function cacheRoot(options) {
  if (options.cacheDir) { return options.cacheDir };
  if (((process.env.HOME === undefined) && (process.env.HOMEDRIVE === undefined))) { throw new Error("HOME not found, unable to store Streamline callback cache") };
  return (((process.env.HOME || ((process.env.HOMEDRIVE + process.env.HOMEPATH)).replace(/\\/g, "/"))) + "/.streamline");};


var dirMode = parseInt("777", 8);

function mkdirs(_, path) { var p, i, segs, seg; var __frame = { name: "mkdirs", line: 260 }; return __func(_, this, arguments, mkdirs, 0, __frame, function __$mkdirs() {
    p = "";
    i = 0;
    segs = path.split("/").slice(0, -1); return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$mkdirs() { __more = false;
        var __3 = (i < segs.length); if (__3) {
          seg = segs[i];
          p += (((i++ ? "/" : "")) + seg);
          return _exists(__cb(_, __frame, 7, 7, function ___(__0, __2) { var __1 = !__2; return (function __$mkdirs(__then) { if (__1) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$mkdirs() {

                      return fs.mkdir(p, dirMode, __cb(_, __frame, 9, 7, __then, true)); }); })(function ___(err, __result) { __catch(function __$mkdirs() { if (err) {

                        if (((i > 1) && (err.code !== "EEXIST"))) {
                          return _(err); } ; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(function __$mkdirs() { while (__more) { __loop(); }; __more = true; }); }, true), p); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(_); });};






function subdir(options) {
  return (options.generators ? ((options.fast ? "generators-fast" : "generators")) : (options.fibers ? ((options.fast ? "fibers-fast" : "fibers")) : "callbacks"));};




function cachedTransform(_, content, path, transform, banner, options) { var i, dir, f, transformed; var __frame = { name: "cachedTransform", line: 285 }; return __func(_, this, arguments, cachedTransform, 0, __frame, function __$cachedTransform() {
    path = path.replace(/\\/g, "/"); return (function __$cachedTransform(__then) {
      if (options.cache) {
        i = path.indexOf("node_modules/");
        if ((i < 0)) { i = path.lastIndexOf("/"); } else {
          i += "node_modules".length; } ;

        dir = ((cacheRoot(options) + "/") + subdir(options));
        dir += ("/" + path.substring(0, i).replace(/[\/\:]/g, "__"));
        f = (dir + path.substring(i));
        return mkdirs(__cb(_, __frame, 10, 2, function __$cachedTransform() {

          return mtime(__cb(_, __frame, 12, 6, function ___(__0, __2) { return mtime(__cb(_, __frame, 12, 20, function ___(__0, __3) { var __1 = (__2 > __3); return (function __$cachedTransform(__then) { if (__1) {
                  return fs.readFile(f, "utf8", __cb(_, __frame, 13, 20, function ___(__0, __4) { transformed = __4;
                    if ((transformed.substring(0, banner.length) === banner)) { return _(null, transformed); } ; __then(); }, true)); } else { __then(); } ; })(__then); }, true), path); }, true), f); }, true), f); } else { __then(); } ; })(function __$cachedTransform() {



      if (options.verbose) { console.log(("streamline: transforming: " + path)); } ;
      options.lines = (options.lines || "sourcemap");
      transformed = (banner + _transform(transform, content, options)); return (function __$cachedTransform(__then) {
        if ((options.cache && (path.indexOf("/tmp--") < 0))) { return fs.writeFile(f, transformed, "utf8", __cb(_, __frame, 21, 53, __then, true)); } else { __then(); } ; })(function __$cachedTransform() {
        return _(null, transformed); }); }); });};


exports.cachedTransformSync = compileSync.cachedTransformSync;

function compileCoffee(_, path, options) { var jsPath, mapPath, outDir, coffeeOpts, source, coffee, compiled, js; var __frame = { name: "compileCoffee", line: 312 }; return __func(_, this, arguments, compileCoffee, 0, __frame, function __$compileCoffee() {
    return outputFile(__cb(_, __frame, 1, 14, function ___(__0, __2) { jsPath = __2;
      mapPath = jsPath.replace(/\.js$/, ".map");
      outDir = fspath.dirname(jsPath);
      coffeeOpts = {
        filename: path,
        sourceMap: options.sourceMap,
        jsPath: jsPath,
        sourceRoot: fspath.relative(outDir, "."),
        sourceFiles: [fspath.relative(".", path),],
        generatedFile: fspath.basename(jsPath) }; return (function __$compileCoffee(_) {

        var __1 = options.force; if (__1) { return _(null, __1); } ; return mtime(__cb(_, __frame, 12, 22, function ___(__0, __3) { return mtime(__cb(_, __frame, 12, 39, function ___(__0, __4) { var __2 = (__3 > __4); return _(null, __2); }, true), jsPath); }, true), path); })(__cb(_, __frame, -311, 6, function ___(__0, __3) { return (function __$compileCoffee(__then) { if (__3) {
            return fs.readFile(path, "utf8", __cb(_, __frame, 13, 18, function ___(__0, __4) { source = __4;
              coffee = require("../util/require")("coffee-script");
              compiled = coffee.compile(source, coffeeOpts);
              if (options.verbose) { console.log(((("streamline: coffee compiling: " + path) + " to ") + jsPath)); } ;

              if (options.sourceMap) {
                js = (((compiled.js + "\n//# sourceMappingURL=") + fspath.basename(mapPath)) + "\n"); }
               else {
                js = compiled; } ; return (function __$compileCoffee(__then) {

                if (options.noWrite) {
                  return _(null, {
                    transformed: js,
                    sourceMap: compiled.v3SourceMap }); } else {



                  return fs.writeFile(jsPath, js, "utf8", __cb(_, __frame, 30, 6, function __$compileCoffee() { return (function __$compileCoffee(__then) {
                      if (options.sourceMap) {
                        return fs.writeFile(mapPath, compiled.v3SourceMap, "utf8", __cb(_, __frame, 32, 7, __then, true)); } else { __then(); } ; })(__then); }, true)); } ; })(__then); }, true)); } else { __then(); } ; })(_); }, true)); }, true), path, options); });};






function _getCompiler(path) {
  var ext = fspath.extname(path);
  if (((ext === "._js") || (ext === "._coffee"))) {
    return exports.compileFile; }
   else if (((ext === ".coffee") && (path[((path.length - ext.length) - 1)] !== "_"))) {
    return compileCoffee; }
   else {  }  ;};






exports.transform = function exports_transform__3(_, path, options) { var compiler; var __frame = { name: "exports_transform__3", line: 364 }; return __func(_, this, arguments, exports_transform__3, 0, __frame, function __$exports_transform__3() {
    options = _extend({
      noWrite: true
    }, (options || { }));
    compiler = _getCompiler(path); return (function __$exports_transform__3(__then) {
      if (compiler) { return compiler(__cb(_, __frame, 5, 15, __then, true), path, options); } else { __then(); } ; })(_); });};








exports.compile = function exports_compile__4(_, paths, options) { var failed, transform, cwd;
  function _compile(_, path, base, options) { var stat, compiler; var __frame = { name: "_compile", line: 379 }; return __func(_, this, arguments, _compile, 0, __frame, function __$_compile() {
      return fs.stat(path, __cb(_, __frame, 1, 16, function ___(__0, __2) { stat = __2; return (function __$_compile(__then) {
          if (stat.isDirectory()) {
            base = (base || path);
            return fs.readdir(path, __cb(_, __frame, 4, 6, function ___(__0, __3) { return __3.forEach_(__cb(_, __frame, 4, 24, __then, true), function __1(_, f) { var __frame = { name: "__1", line: 383 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() {
                  return _compile(__cb(_, __frame, 1, 4, function __$__1() { _(); }, true), ((path + "/") + f), base, options); }); }); }, true)); } else { return (function __$_compile(__then) {

              if (stat.isFile()) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$_compile() {

                      base = (base || fspath.dirname(path));
                      options.baseDir = base;
                      compiler = _getCompiler(path); return (function __$_compile(__then) {
                        if (compiler) { return compiler(__cb(_, __frame, 12, 18, __then, true), path, options); } else { __then(); } ; })(__then); }); })(function ___(ex, __result) { __catch(function __$_compile() { if (ex) {

                        console.error(ex.stack);
                        failed++; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(__then); } ; })(_); }, true)); }); }; var __frame = { name: "exports_compile__4", line: 378 }; return __func(_, this, arguments, exports_compile__4, 0, __frame, function __$exports_compile__4() {





    failed = 0;
    options = (options || { });
    transform = _getTransform(options);
    if (options.verbose) { console.log(("transform version: " + transform.version)); } ;
    if ((!paths || (paths.length == 0))) { return _(new Error("cannot compile: no files specified")); } ;
    cwd = process.cwd();
    return paths.forEach_(__cb(_, __frame, 28, 7, function __$exports_compile__4() {


      if (failed) { return _(new Error((("errors found in " + failed) + " files"))); } ; _(); }, true), function __1(_, path) { var __frame = { name: "__1", line: 406 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return _compile(__cb(_, __frame, 1, 2, function __$__1() { _(); }, true), fspath.resolve(cwd, path), null, options); }); }); });};
