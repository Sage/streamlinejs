/*** Generated by streamline 0.1.39 - DO NOT EDIT ***/ "use strict"; var __g=typeof global!=='undefined'?global:window;__g=(__g.__streamline||(__g.__streamline={}));__g.setEF=__g.setEF||function(e,f){e.__frame = e.__frame||f};__g.cbTick = 0;var __nextTick=(typeof process!='undefined'&&typeof process.nextTick=='function')?process.nextTick:function(fn){setTimeout(function(){fn()},0);};var __srcName='./lib/streams/readers_.js'; function __func(_, __this, __arguments, fn, index, frame, body){ if (!_) { return __future.call(__this, fn, __arguments, index); } frame.file = __srcName; frame.prev = __g.frame; if ((__g.cbTick = ++__g.cbTick % 100) === 0) return __nextTick(__cb(_, frame, -1, 0, body)); __g.frame = frame; try { body(); } catch (e) { __g.setEF(e, frame.prev); __propagate(_, e); } finally { __g.frame = frame.prev; } } function __cb(_, frame, offset, col, fn){ frame.offset = offset; frame.col = col; var ctx = __g.context; return function ___(err, result){ var oldFrame = __g.frame; __g.frame = frame; __g.context = ctx; try { if (err) { __g.setEF(err, frame); return _(err); } return fn(null, result); } catch (ex) { __g.setEF(ex, frame); return __propagate(_, ex); } finally { __g.frame = oldFrame; } } } function __future(fn, args, i){ var done, err, result; var cb = function(e, r){ done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function ___(e, r){ cb(e, r); }; fn.apply(this, args); return function ___(_){ if (done) _.call(this, err, result); else cb = _.bind(this); } .bind(this); } function __nt(_, frame, fn){ var cb = __cb(_, frame, 0, 0, fn); return function ___(){ if ((__g.cbTick = ++__g.cbTick % 100) === 0) __nextTick(cb); else cb(); }; } function __propagate(_, err){ try { _(err); } catch (ex) { __trap(ex); } } function __trap(err){ if (err) { if (__g.context && __g.context.errorHandler) __g.context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } } var streams = require("./streams");
















exports.Reader = function(stream, boundary, options) {
 options = (options || { });
 options.defaultSize = (options.defaultSize || 512);
 if ((!stream.emitter && (typeof stream.on === "function"))) {

 stream = new streams.ReadableStream(stream, options);
 stream.setEncoding((options.encoding || "utf8")); };

 if (!boundary) {
 boundary = "\n"; };
 this.readItem = function readItem__1(_) { var chunks, len, chunk, i; var __frame = { name: "readItem__1", line: 28 }; return __func(_, this, arguments, readItem__1, 0, __frame, function __$readItem__1() {
 chunks = [];
 len = options.defaultSize; return (function ___(__break) { var __loop = __nt(_, __frame, function __$readItem__1() {
 var __2 = stream; if (__2) {
 return stream.read(__cb(_, __frame, 4, 15, function ___(__0, __1) { chunk = __1;
 if ((chunk == null)) {
 stream = null; }
 else {
 i = chunk.indexOf(boundary);
 if ((i >= 0)) {
 stream.unread(chunk.substring((i + boundary.length)));
 chunks.push(chunk.substring(0, i)); return __break(); } else {

 if ((chunk.length == (len + boundary.length))) {
 stream.unread(chunk.substring(len));
 chunks.push(chunk.substring(0, len)); }
 else {
 return _(new Error(((("missing boundary:" + boundary) + " in: ") + chunk))); } ; } ; } ; __loop(); }), (len + boundary.length)); } else { __break(); } ; }); __loop(); })(function __$readItem__1() {



 return _(null, ((chunks.length == 0) ? null : chunks.join(""))); }); }); };

 this.close = function close__2(_) { var __frame = { name: "close__2", line: 51 }; return __func(_, this, arguments, close__2, 0, __frame, function __$close__2() {
 stream = null; _(); }); };};